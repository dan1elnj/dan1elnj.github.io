---
title: "TryHackMe - W1seGuy"
date: 2025-10-15
lastmod: 2025-10-15
categories: [TryHackMe]
tags: [Source Code, TryHackMe, CTF, Cryptography, XOR]
toc: true
math: false
mermaid: true
image:
  path: assets/img/TryHackMe/W1seGuy/logo.png
---

## Target
- **Host:** `10.10.204.24`  
- **Plataforma:** TryHackMe   
- **Nivel:** <span style="color: #66bb6a;">Easy</span>
- **Objetivo:** Encontrar las 2 flags.

---

## Introduccion

Este writeup muestra cómo analizar un script Python que cifra una fake flag con XOR y pide una clave al cliente. Explico el código línea a línea con términos claros, cómo recuperar la clave  on script, y qué medidas tomar para corregir el problema. Está pensado para alguien que no sabe Python ni conceptos de criptografía.


## Conceptos Clave

Para entender cómo funciona este programa, solo necesitas tres ideas:

1. **Servidor y Conexión**

    **Servidor**: Imagina una emisora de radio secreta que espera que te sintonices. Su misión es enviarte un mensaje (el texto cifrado) y luego hacerte una pregunta.

    **Conexión (nc)**: Es tu radio virtual (nc o netcat). Te permite "sintonizar" el servidor para que puedan intercambiar mensajes.

2. **El Cifrado XOR**

El cifrado es una forma de mezclar dos mensajes (el mensaje original y una clave secreta) para obtener un mensaje codificado.

    **Fórmula Mágica**: Si tienes Mensaje Original XOR Clave Secreta = Mensaje Codificado.

    **La Clave del Hacker**: Lo crucial es que es reversible. Si tienes el Mensaje Codificado XOR Mensaje Original = ¡obtienes la Clave Secreta!

        C⊕P=K (Donde C=Codificado, P=Original, K=Clave)

3. **Known-Plaintext (El Secreto Revelado)**

Esto significa que el código fuente del servidor nos revela cuál era el mensaje original (el plaintext) que se cifró.

    **Situación**: Si sabemos qué mensaje se cifró (Mensaje Original) y el servidor nos envía el resultado (Mensaje Codificado), podemos usar la reversibilidad del XOR para calcular la Clave Secreta.

## Codigo Fuente
```python
import random
import socketserver 
import socket, os
import string

flag = open('flag.txt','r').read().strip()

def send_message(server, message):
    enc = message.encode()
    server.send(enc)

def setup(server, key):
    flag = 'THM{thisisafakeflag}' 
    xored = ""

    for i in range(0,len(flag)):
        xored += chr(ord(flag[i]) ^ ord(key[i%len(key)]))

    hex_encoded = xored.encode().hex()
    return hex_encoded

def start(server):
    res = ''.join(random.choices(string.ascii_letters + string.digits, k=5))
    key = str(res)
    hex_encoded = setup(server, key)
    send_message(server, "This XOR encoded text has flag 1: " + hex_encoded + "\n")
    
    send_message(server,"What is the encryption key? ")
    key_answer = server.recv(4096).decode().strip()

    try:
        if key_answer == key:
            send_message(server, "Congrats! That is the correct key! Here is flag 2: " + flag + "\n")
            server.close()
        else:
            send_message(server, 'Close but no cigar' + "\n")
            server.close()
    except:
        send_message(server, "Something went wrong. Please try again. :)\n")
        server.close()

class RequestHandler(socketserver.BaseRequestHandler):
    def handle(self):
        start(self.request)

if __name__ == '__main__':
    socketserver.ThreadingTCPServer.allow_reuse_address = True
    server = socketserver.ThreadingTCPServer(('0.0.0.0', 1337), RequestHandler)
    server.serve_forever()
```


## Análisis del codigo fuente 

### 1. Estructura general del programa

El script es un servidor TCP que realiza este flujo cada vez que un cliente se conecta:

  1. Carga la flag real desde flag.txt en memoria.

  2. Genera una key (cadena aleatoria de 5 caracteres).

  3. Cifra una fake flag fija con XOR usando esa key repetida y convierte el resultado a texto hexadecimal.

  4. Envía el texto hexadecimal al cliente y le pide la key.

  5. Si el cliente responde exactamente la key generada, envía la flag real; si no, cierra la conexión.

Ahora vemos cada bloque con detalle técnico y lenguaje sencillo.



### 1. Inicialización y Dependencias

Esta sección define las herramientas que el programa necesita para funcionar.
```python
import random
import socketserver 
import socket, os
import string

flag = open('flag.txt','r').read().strip()
```
- `import random`, `import string` — traen utilidades para generar cadenas aleatorias y manejar caracteres.

- `import socketserver`, `import socket`, `import os` — traen utilidades para servidor y comunicación por red; `os` para posibles operaciones del sistema.

- `flag = open('flag.txt','r').read().strip()`:

  - `open('flag.txt','r')` abre el archivo en modo lectura.

  - `.read()` lee todo el contenido del archivo como una cadena de texto.

  - `.strip()` elimina espacios o saltos de línea al inicio y final.

  - Resultado: la variable `flag` contiene la flag real (texto) lista para usarse más adelante.

Punto importante de seguridad: leer la flag al inicio y guardarla en una variable permite que, si el programa falla en control de acceso, la flag pueda ser expuesta. En este programa la flag real sólo se envía si la clave es correcta.

### 2. Función para enviar datos por la conexión

```python
def send_message(server, message):
    enc = message.encode()
    server.send(enc)
```
- `def send_message(server, message)`: — define una función llamada `send_message` que recibe:

  - `server`: objeto que representa la conexión del cliente (socket).

  - `message`: cadena de texto a enviar.

- `enc = message.encode()` — convierte la cadena `message` a bytes usando la codificación por defecto (UTF-8). La red transmite bytes, no cadenas de texto.

- `server.send(enc)` — envía los bytes a través del socket conectado al cliente.

**Nota técnica: `send` puede no enviar todos los bytes en situaciones de cargas grandes; aquí el mensaje es pequeño, por eso se usa `send` en lugar de `sendall`. Para mayor robustez usar `sendall`.

### 3. Función setup: cifrado XOR y salida en hex

```python
def setup(server, key):
    flag = 'THM{thisisafakeflag}' 
    xored = ""

    for i in range(0,len(flag)):
        xored += chr(ord(flag[i]) ^ ord(key[i%len(key)]))

    hex_encoded = xored.encode().hex()
    return hex_encoded
```

Explicación línea por línea:

- `def setup(server, key)`: — función que prepara el texto cifrado; recibe `server` (no usado dentro de la función) y `key` (cadena de 5 caracteres).

- `flag = 'THM{thisisafakeflag}'` — fake flag fija. Esta cadena es el plaintext conocido por quien lea el código.

- `xored = ""` — inicializa una cadena vacía que guardará el resultado del XOR, carácter por carácter.

- `for i in range(0,len(flag)):` — bucle que itera i desde 0 hasta len(flag)-1. i representa la posición del carácter actual.

- `xored += chr(ord(flag[i]) ^ ord(key[i%len(key)]))` — operación central; desglosada:

    - `flag[i]` es el carácter del plaintext en la posición i.

    - `key[i%len(key)]` selecciona un carácter de la key en la posición i modulo len(key). Esto hace que la key se repita cuando i supera la longitud de la key.

    - `ord(char)` devuelve el código numérico (entero) del carácter char.

    - `^` es el operador XOR a nivel de enteros.

    - `chr(n)` convierte el entero resultante de XOR de vuelta a un carácter.

    - `xored += ...` concatena ese carácter al final de la cadena xored.

- `hex_encoded = xored.encode().hex()`:

    - `xored.encode()` convierte la cadena resultante a bytes (UTF-8).

    - `.hex()` transforma esos bytes en su representación hexadecimal (una cadena con caracteres `0-9a-f`, dos caracteres por byte).

- `return hex_encoded` — devuelve la cadena hexadecimal.

**Punto técnico crucial**: la función usa una fake flag conocida como texto plano. Eso la convierte en un caso de known-plaintext. Si el ciphertext (hex) es accesible (lo envía el servidor), entonces es trivial recuperar la key aplicando XOR del ciphertext con el plaintext conocido.

### 4. Generación de la clave y protocolo de interacción con el cliente

```python
def start(server):
    res = ''.join(random.choices(string.ascii_letters + string.digits, k=5))
    key = str(res) # <--- La clave secreta (5 chars)
    
    # ... Llama a setup() para cifrar ...
    
    send_message(server, "This XOR encoded text has flag 1: " + hex_encoded + "\n") # Envía el texto cifrado
    send_message(server,"What is the encryption key? ")
    
    key_answer = server.recv(4096).decode().strip() # Espera la respuesta
    
    # ... Lógica de validación ...
```

- `res = ''.join(random.choices(string.ascii_letters + string.digits, k=5))`:

    - `random.choices(...)` selecciona `k=5` caracteres aleatorios de la lista `string.ascii_letters + string.digits` (letras mayúsculas, minúsculas y dígitos).

    - `''.join(...)` convierte la lista de caracteres en una cadena sin separadores.

    - Resultado: `res` es una cadena de 5 caracteres aleatorios.

- `key = str(res)` — asegura que key sea una cadena (ya lo es).

- `hex_encoded = setup(server, key)` — llama a la función que cifra la fake flag con la key y devuelve el ciphertext en hex.

- `send_message(... "This XOR encoded text has flag 1: " + hex_encoded + "\n")` — envía el ciphertext al cliente.

- `send_message(... "What is the encryption key? ")` — pregunta por la clave.

- `key_answer = server.recv(4096).decode().strip()`:

    - `server.recv(4096)` recibe hasta 4096 bytes enviados por el cliente.

    - `.decode()` convierte esos bytes a cadena de texto.

    - `.strip()` elimina saltos de línea y espacios al principio y al final.

Nota: `recv` bloquea hasta recibir datos o cerrar la conexión; por eso esta llamada espera la respuesta del cliente.


### 5. Validación de la respuesta y envío de la flag real

Esta sección pone el servicio en línea.

```python
    try:
        if key_answer == key:
            send_message(server, "Congrats! That is the correct key! Here is flag 2: " + flag + "\n")
            server.close()
        else:
            send_message(server, 'Close but no cigar' + "\n")
            server.close()
    except:
        send_message(server, "Something went wrong. Please try again. :)\n")
        server.close()
```

- `try` / `except` — bloque de manejo de errores; evita que excepciones sin control derriben el servidor.

- `if key_answer == key:` — compara exactamente la respuesta del cliente con la `key` generada.

    - Si son iguales: envía la `flag real` (`flag`) y cierra la conexión (`server.close()`).

    - Si no: envía un mensaje de fallo y cierra la conexión.

- `except:` — atrapa cualquier excepción no esperada, informa al cliente y cierra la conexión.

**Comentario operativo**: la comparación es de texto exacto (case-sensitive). No hay tolerancia a espacios o a mayúsculas/minúsculas.

### 6. Clase manejadora y arranque del servidor

```python
class RequestHandler(socketserver.BaseRequestHandler):
    def handle(self):
        start(self.request)

if __name__ == '__main__':
    socketserver.ThreadingTCPServer.allow_reuse_address = True
    server = socketserver.ThreadingTCPServer(('0.0.0.0', 1337), RequestHandler)
    server.serve_forever()
```
- `class RequestHandler(socketserver.BaseRequestHandler):` — define una clase que especifica qué hacer con cada conexión entrante. BaseRequestHandler es la interfaz que espera socketserver.

- `def handle(self): start(self.request)` — al recibir conexión, se llama a handle y allí se ejecuta start pasando self.request (el socket de la conexión).

- `if __name__ == '__main__':` — verifica que el script se ejecuta directamente (no importado).

- `socketserver.ThreadingTCPServer.allow_reuse_address = True` — permite reutilizar el puerto sin esperar a que el sistema lo libere tras un cierre.

- `server = socketserver.ThreadingTCPServer(('0.0.0.0', 1337), RequestHandler)` — crea un servidor TCP en todas las interfaces (`0.0.0.0`), puerto `1337`, que atiende cada conexión en un hilo independiente.

- `server.serve_forever()` — pone el servidor a escuchar y atender conexiones de forma indefinida hasta que se detenga el proceso.

Consideración de escalabilidad/robustez: usar `ThreadingTCPServer` abre un hilo por conexión. Para muchas conexiones esto puede consumir muchos recursos; alternativas son usar manejadores asíncronos.

### 7. Explicación técnica de las operaciones clave

XOR (`^`)

    - Opera entre enteros (bits). Si a y b son enteros, a ^ b devuelve otro entero.

    - Propiedad fundamental: si c = a ^ b entonces a = c ^ b y b = c ^ a. Esto da la reversibilidad usada en el reto.

`ord(char)` y `chr(int)`

    - ord('A') → devuelve un entero (por ejemplo 65) que representa el carácter en Unicode/ASCII.

    - chr(65) → devuelve la cadena 'A'.

    - En el código: se usa `ord` para convertir caracteres a enteros, aplicar XOR, y `chr` para volver a convertir a caracteres.

`.encode()` y `.hex()`

    - .encode() convierte una cadena de texto en bytes (UTF-8 por defecto).

    - .hex() aplicada a bytes devuelve una cadena con la representación hexadecimal de esos bytes.

`recv` y `send`

    - recv(n) lee hasta n bytes del socket; es bloqueante hasta que hay datos o la conexión se cierra.

    - send(bytes) intenta enviar bytes al socket; puede enviar menos que la longitud pasada. Para asegurar envío total usar sendall.

## Explotación

### 1. Recolectar la Información

Usamos la herramienta nc (netcat) para conectarnos al servidor y obtener el mensaje codificado.

![nc](assets/img/TryHackMe/W1seGuy/nc.png)


### 2. Calculando la Clave Secreta



Este script realiza la "Operación Mágica Inversa" para descifrar la clave de 5 caracteres.

```python
# -*- coding: utf-8 -*-
import socket
import string
import sys
import time

# --- CONFIGURACIÓN ---
# ¡IMPORTANTE! Reemplaza "w1seguy.thm" con la IP o nombre de host correcto si es necesario.
HOST = "w1seguy.thm" 
PORT = 1337

# El servidor genera la clave a partir de este conjunto:
KEY_CHARS = string.ascii_letters + string.digits

def setup(key, flag, encode):
    """Aplica la operación XOR: Flag XOR Key"""
    xored = ""

    # Itera sobre la longitud de la Flag. El operador % len(key) repite la clave.
    for i in range(0,len(flag)):
        xored += chr(ord(flag[i]) ^ ord(key[i%len(key)]))

    if encode:
        # Convierte el resultado XOR a HEX para la comparación con el servidor
        # Usamos latin1 para manejar caracteres no ASCII
        return xored.encode('latin1').hex()

    # Devuelve la Flag descifrada (Mensaje Original)
    return xored

def main():
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.connect((HOST, PORT))
            s.settimeout(2.0) # Establece un timeout para evitar bloqueos

            # 1. RECIBIR DATOS Y EXTRAER CIFRADO (C)
            
            data = s.recv(4096).decode('utf-8')
            xor_text = ""

            # Bucle para extraer el texto cifrado
            if "This XOR encoded text has flag 1" in data:
                # La cadena HEX está después de los dos puntos
                xor_text = data.split(":")[1].strip().split('\n')[0].strip()
            
            if not xor_text:
                print("❌ Error: No se pudo extraer el texto cifrado.")
                sys.exit(1)

            print(f"✅ Paso 1: Texto Cifrado (C) extraído.")
            
            # 2. CALCULAR LA CLAVE (K) POR FUERZA BRUTA DE CONOCIDOS
            
            final_key = ""
            # Sabemos que la Flag 1 (descifrada) empieza con 'THM{'
            known_parts = ["T", "H", "M", "{"] 
            
            # Buscamos los primeros 4 caracteres de la clave
            for i in range(4):
                hex_pair = xor_text[i*2:(i*2)+2] # Extrae los 2 chars HEX (1 byte cifrado)
                known_char = known_parts[i]
                
                # Pruebas de fuerza bruta: (Key XOR Known_Char) debe ser igual a Hex_Pair
                for k_char in KEY_CHARS:
                    if setup(k_char, known_char, True) == hex_pair:
                        final_key += k_char
                        break

            # Buscar el 5to carácter de la clave, asumiendo que la Flag 1 termina en '}'
            for k_char in KEY_CHARS:
                tmp_key = final_key + k_char
                
                # Descifrar la Flag 1 con la clave de 5 caracteres
                flag_descifrada = setup(tmp_key, bytes.fromhex(xor_text).decode('latin1'), False)
                
                # Comprobar si el último carácter es '}' (formato THM{})
                if flag_descifrada.endswith("}"): 
                    final_key = tmp_key
                    break
            
            if len(final_key) < 5:
                print("❌ Error: No se pudo completar la clave de 5 caracteres.")
                sys.exit(1)
            
            print(f"🔑 Paso 2: Clave Secreta calculada: {final_key}")
            
            # 3. ENVIAR LA CLAVE (K) Y OBTENER FLAG 2
            
            # Enviar la clave al servidor INMEDIATAMENTE con salto de línea (\r\n para robustez)
            s.sendall((final_key + "\r\n").encode('utf-8'))
            
            # 4. Leer la respuesta completa (Flag 2)
            response = b""
            try:
                while True:
                    chunk = s.recv(4096)
                    if not chunk:
                        break
                    response += chunk
            except socket.timeout:
                pass 
                
            data = response.decode('utf-8')

            print("\n" + "=" * 40)
            print("RESULTADO FINAL:")
            
            # Imprimir Flag 2
            print(f"Returned text: {data.strip()}") 
            
            # Imprimir Flag 1 (la descifrada)
            flag_descifrada = setup(final_key, bytes.fromhex(xor_text).decode('latin1'), False)
            print(f"La Flag 1 descifrada es: {flag_descifrada} con clave {final_key}")
            print("=" * 40)

    except Exception as e:
        print(f"\n❌ Ocurrió un error en la conexión o el script: {e}")

if __name__ == "__main__":
    main()
```

Ejecuta el script y obtendrás ambas flags.

![clave](assets/img/TryHackMe/W1seGuy/clave.png)


- flag1: THM{p1alntExtAtt4ckcAnr3alLyhUrty0urxOr}
- flag2: THM{BrUt3_ForC1nG_XOR_cAn_B3_FuN_nO?}

## Conclusión

La criptografía y el analisis de codigo en mi opinion es uno de los campos mas dificiles para mi, que aun con ayuda de IA me ha costado bastantes horas resolver esta maquina, sin duda la ia me ha ayudado mucho a analizar el codigo y generar scripts sin conocimientos apenas.
Siempre es bueno saber un poco de todo, tanto programación como criptografía, espero que os haya gustado.
