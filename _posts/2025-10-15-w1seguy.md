---
title: "TryHackMe - W1seGuy"
date: 2025-10-15
lastmod: 2025-10-15
categories: [TryHackMe]
tags: [Source Code, TryHackMe, CTF, Cryptography, XOR]
toc: true
math: false
mermaid: true
image:
  path: assets/img/TryHackMe/W1seGuy/logo.png
---

## Target
- **Host:** `10.10.204.24`  
- **Plataforma:** TryHackMe   
- **Nivel:** <span style="color: #66bb6a;">Easy</span>
- **Objetivo:** Encontrar las 2 flags.

---

## Introduccion

Este writeup muestra c√≥mo analizar un script Python que cifra una fake flag con XOR y pide una clave al cliente. Explico el c√≥digo l√≠nea a l√≠nea con t√©rminos claros, c√≥mo recuperar la clave  on script, y qu√© medidas tomar para corregir el problema. Est√° pensado para alguien que no sabe Python ni conceptos de criptograf√≠a.


## Conceptos Clave

Para entender c√≥mo funciona este programa, solo necesitas tres ideas:

1. **Servidor y Conexi√≥n**

    **Servidor**: Imagina una emisora de radio secreta que espera que te sintonices. Su misi√≥n es enviarte un mensaje (el texto cifrado) y luego hacerte una pregunta.

    **Conexi√≥n (nc)**: Es tu radio virtual (nc o netcat). Te permite "sintonizar" el servidor para que puedan intercambiar mensajes.

2. **El Cifrado XOR**

El cifrado es una forma de mezclar dos mensajes (el mensaje original y una clave secreta) para obtener un mensaje codificado.

    **F√≥rmula M√°gica**: Si tienes Mensaje Original XOR Clave Secreta = Mensaje Codificado.

    **La Clave del Hacker**: Lo crucial es que es reversible. Si tienes el Mensaje Codificado XOR Mensaje Original = ¬°obtienes la Clave Secreta!

        C‚äïP=K (Donde C=Codificado, P=Original, K=Clave)

3. **Known-Plaintext (El Secreto Revelado)**

Esto significa que el c√≥digo fuente del servidor nos revela cu√°l era el mensaje original (el plaintext) que se cifr√≥.

    **Situaci√≥n**: Si sabemos qu√© mensaje se cifr√≥ (Mensaje Original) y el servidor nos env√≠a el resultado (Mensaje Codificado), podemos usar la reversibilidad del XOR para calcular la Clave Secreta.

## Codigo Fuente
```python
import random
import socketserver 
import socket, os
import string

flag = open('flag.txt','r').read().strip()

def send_message(server, message):
    enc = message.encode()
    server.send(enc)

def setup(server, key):
    flag = 'THM{thisisafakeflag}' 
    xored = ""

    for i in range(0,len(flag)):
        xored += chr(ord(flag[i]) ^ ord(key[i%len(key)]))

    hex_encoded = xored.encode().hex()
    return hex_encoded

def start(server):
    res = ''.join(random.choices(string.ascii_letters + string.digits, k=5))
    key = str(res)
    hex_encoded = setup(server, key)
    send_message(server, "This XOR encoded text has flag 1: " + hex_encoded + "\n")
    
    send_message(server,"What is the encryption key? ")
    key_answer = server.recv(4096).decode().strip()

    try:
        if key_answer == key:
            send_message(server, "Congrats! That is the correct key! Here is flag 2: " + flag + "\n")
            server.close()
        else:
            send_message(server, 'Close but no cigar' + "\n")
            server.close()
    except:
        send_message(server, "Something went wrong. Please try again. :)\n")
        server.close()

class RequestHandler(socketserver.BaseRequestHandler):
    def handle(self):
        start(self.request)

if __name__ == '__main__':
    socketserver.ThreadingTCPServer.allow_reuse_address = True
    server = socketserver.ThreadingTCPServer(('0.0.0.0', 1337), RequestHandler)
    server.serve_forever()
```


## An√°lisis del codigo fuente 

### 1. Estructura general del programa

El script es un servidor TCP que realiza este flujo cada vez que un cliente se conecta:

  1. Carga la flag real desde flag.txt en memoria.

  2. Genera una key (cadena aleatoria de 5 caracteres).

  3. Cifra una fake flag fija con XOR usando esa key repetida y convierte el resultado a texto hexadecimal.

  4. Env√≠a el texto hexadecimal al cliente y le pide la key.

  5. Si el cliente responde exactamente la key generada, env√≠a la flag real; si no, cierra la conexi√≥n.

Ahora vemos cada bloque con detalle t√©cnico y lenguaje sencillo.



### 1. Inicializaci√≥n y Dependencias

Esta secci√≥n define las herramientas que el programa necesita para funcionar.
```python
import random
import socketserver 
import socket, os
import string

flag = open('flag.txt','r').read().strip()
```
- `import random`, `import string` ‚Äî traen utilidades para generar cadenas aleatorias y manejar caracteres.

- `import socketserver`, `import socket`, `import os` ‚Äî traen utilidades para servidor y comunicaci√≥n por red; `os` para posibles operaciones del sistema.

- `flag = open('flag.txt','r').read().strip()`:

  - `open('flag.txt','r')` abre el archivo en modo lectura.

  - `.read()` lee todo el contenido del archivo como una cadena de texto.

  - `.strip()` elimina espacios o saltos de l√≠nea al inicio y final.

  - Resultado: la variable `flag` contiene la flag real (texto) lista para usarse m√°s adelante.

Punto importante de seguridad: leer la flag al inicio y guardarla en una variable permite que, si el programa falla en control de acceso, la flag pueda ser expuesta. En este programa la flag real s√≥lo se env√≠a si la clave es correcta.

### 2. Funci√≥n para enviar datos por la conexi√≥n

```python
def send_message(server, message):
    enc = message.encode()
    server.send(enc)
```
- `def send_message(server, message)`: ‚Äî define una funci√≥n llamada `send_message` que recibe:

  - `server`: objeto que representa la conexi√≥n del cliente (socket).

  - `message`: cadena de texto a enviar.

- `enc = message.encode()` ‚Äî convierte la cadena `message` a bytes usando la codificaci√≥n por defecto (UTF-8). La red transmite bytes, no cadenas de texto.

- `server.send(enc)` ‚Äî env√≠a los bytes a trav√©s del socket conectado al cliente.

**Nota t√©cnica: `send` puede no enviar todos los bytes en situaciones de cargas grandes; aqu√≠ el mensaje es peque√±o, por eso se usa `send` en lugar de `sendall`. Para mayor robustez usar `sendall`.

### 3. Funci√≥n setup: cifrado XOR y salida en hex

```python
def setup(server, key):
    flag = 'THM{thisisafakeflag}' 
    xored = ""

    for i in range(0,len(flag)):
        xored += chr(ord(flag[i]) ^ ord(key[i%len(key)]))

    hex_encoded = xored.encode().hex()
    return hex_encoded
```

Explicaci√≥n l√≠nea por l√≠nea:

- `def setup(server, key)`: ‚Äî funci√≥n que prepara el texto cifrado; recibe `server` (no usado dentro de la funci√≥n) y `key` (cadena de 5 caracteres).

- `flag = 'THM{thisisafakeflag}'` ‚Äî fake flag fija. Esta cadena es el plaintext conocido por quien lea el c√≥digo.

- `xored = ""` ‚Äî inicializa una cadena vac√≠a que guardar√° el resultado del XOR, car√°cter por car√°cter.

- `for i in range(0,len(flag)):` ‚Äî bucle que itera i desde 0 hasta len(flag)-1. i representa la posici√≥n del car√°cter actual.

- `xored += chr(ord(flag[i]) ^ ord(key[i%len(key)]))` ‚Äî operaci√≥n central; desglosada:

    - `flag[i]` es el car√°cter del plaintext en la posici√≥n i.

    - `key[i%len(key)]` selecciona un car√°cter de la key en la posici√≥n i modulo len(key). Esto hace que la key se repita cuando i supera la longitud de la key.

    - `ord(char)` devuelve el c√≥digo num√©rico (entero) del car√°cter char.

    - `^` es el operador XOR a nivel de enteros.

    - `chr(n)` convierte el entero resultante de XOR de vuelta a un car√°cter.

    - `xored += ...` concatena ese car√°cter al final de la cadena xored.

- `hex_encoded = xored.encode().hex()`:

    - `xored.encode()` convierte la cadena resultante a bytes (UTF-8).

    - `.hex()` transforma esos bytes en su representaci√≥n hexadecimal (una cadena con caracteres `0-9a-f`, dos caracteres por byte).

- `return hex_encoded` ‚Äî devuelve la cadena hexadecimal.

**Punto t√©cnico crucial**: la funci√≥n usa una fake flag conocida como texto plano. Eso la convierte en un caso de known-plaintext. Si el ciphertext (hex) es accesible (lo env√≠a el servidor), entonces es trivial recuperar la key aplicando XOR del ciphertext con el plaintext conocido.

### 4. Generaci√≥n de la clave y protocolo de interacci√≥n con el cliente

```python
def start(server):
    res = ''.join(random.choices(string.ascii_letters + string.digits, k=5))
    key = str(res) # <--- La clave secreta (5 chars)
    
    # ... Llama a setup() para cifrar ...
    
    send_message(server, "This XOR encoded text has flag 1: " + hex_encoded + "\n") # Env√≠a el texto cifrado
    send_message(server,"What is the encryption key? ")
    
    key_answer = server.recv(4096).decode().strip() # Espera la respuesta
    
    # ... L√≥gica de validaci√≥n ...
```

- `res = ''.join(random.choices(string.ascii_letters + string.digits, k=5))`:

    - `random.choices(...)` selecciona `k=5` caracteres aleatorios de la lista `string.ascii_letters + string.digits` (letras may√∫sculas, min√∫sculas y d√≠gitos).

    - `''.join(...)` convierte la lista de caracteres en una cadena sin separadores.

    - Resultado: `res` es una cadena de 5 caracteres aleatorios.

- `key = str(res)` ‚Äî asegura que key sea una cadena (ya lo es).

- `hex_encoded = setup(server, key)` ‚Äî llama a la funci√≥n que cifra la fake flag con la key y devuelve el ciphertext en hex.

- `send_message(... "This XOR encoded text has flag 1: " + hex_encoded + "\n")` ‚Äî env√≠a el ciphertext al cliente.

- `send_message(... "What is the encryption key? ")` ‚Äî pregunta por la clave.

- `key_answer = server.recv(4096).decode().strip()`:

    - `server.recv(4096)` recibe hasta 4096 bytes enviados por el cliente.

    - `.decode()` convierte esos bytes a cadena de texto.

    - `.strip()` elimina saltos de l√≠nea y espacios al principio y al final.

Nota: `recv` bloquea hasta recibir datos o cerrar la conexi√≥n; por eso esta llamada espera la respuesta del cliente.


### 5. Validaci√≥n de la respuesta y env√≠o de la flag real

Esta secci√≥n pone el servicio en l√≠nea.

```python
    try:
        if key_answer == key:
            send_message(server, "Congrats! That is the correct key! Here is flag 2: " + flag + "\n")
            server.close()
        else:
            send_message(server, 'Close but no cigar' + "\n")
            server.close()
    except:
        send_message(server, "Something went wrong. Please try again. :)\n")
        server.close()
```

- `try` / `except` ‚Äî bloque de manejo de errores; evita que excepciones sin control derriben el servidor.

- `if key_answer == key:` ‚Äî compara exactamente la respuesta del cliente con la `key` generada.

    - Si son iguales: env√≠a la `flag real` (`flag`) y cierra la conexi√≥n (`server.close()`).

    - Si no: env√≠a un mensaje de fallo y cierra la conexi√≥n.

- `except:` ‚Äî atrapa cualquier excepci√≥n no esperada, informa al cliente y cierra la conexi√≥n.

**Comentario operativo**: la comparaci√≥n es de texto exacto (case-sensitive). No hay tolerancia a espacios o a may√∫sculas/min√∫sculas.

### 6. Clase manejadora y arranque del servidor

```python
class RequestHandler(socketserver.BaseRequestHandler):
    def handle(self):
        start(self.request)

if __name__ == '__main__':
    socketserver.ThreadingTCPServer.allow_reuse_address = True
    server = socketserver.ThreadingTCPServer(('0.0.0.0', 1337), RequestHandler)
    server.serve_forever()
```
- `class RequestHandler(socketserver.BaseRequestHandler):` ‚Äî define una clase que especifica qu√© hacer con cada conexi√≥n entrante. BaseRequestHandler es la interfaz que espera socketserver.

- `def handle(self): start(self.request)` ‚Äî al recibir conexi√≥n, se llama a handle y all√≠ se ejecuta start pasando self.request (el socket de la conexi√≥n).

- `if __name__ == '__main__':` ‚Äî verifica que el script se ejecuta directamente (no importado).

- `socketserver.ThreadingTCPServer.allow_reuse_address = True` ‚Äî permite reutilizar el puerto sin esperar a que el sistema lo libere tras un cierre.

- `server = socketserver.ThreadingTCPServer(('0.0.0.0', 1337), RequestHandler)` ‚Äî crea un servidor TCP en todas las interfaces (`0.0.0.0`), puerto `1337`, que atiende cada conexi√≥n en un hilo independiente.

- `server.serve_forever()` ‚Äî pone el servidor a escuchar y atender conexiones de forma indefinida hasta que se detenga el proceso.

Consideraci√≥n de escalabilidad/robustez: usar `ThreadingTCPServer` abre un hilo por conexi√≥n. Para muchas conexiones esto puede consumir muchos recursos; alternativas son usar manejadores as√≠ncronos.

### 7. Explicaci√≥n t√©cnica de las operaciones clave

XOR (`^`)

    - Opera entre enteros (bits). Si a y b son enteros, a ^ b devuelve otro entero.

    - Propiedad fundamental: si c = a ^ b entonces a = c ^ b y b = c ^ a. Esto da la reversibilidad usada en el reto.

`ord(char)` y `chr(int)`

    - ord('A') ‚Üí devuelve un entero (por ejemplo 65) que representa el car√°cter en Unicode/ASCII.

    - chr(65) ‚Üí devuelve la cadena 'A'.

    - En el c√≥digo: se usa `ord` para convertir caracteres a enteros, aplicar XOR, y `chr` para volver a convertir a caracteres.

`.encode()` y `.hex()`

    - .encode() convierte una cadena de texto en bytes (UTF-8 por defecto).

    - .hex() aplicada a bytes devuelve una cadena con la representaci√≥n hexadecimal de esos bytes.

`recv` y `send`

    - recv(n) lee hasta n bytes del socket; es bloqueante hasta que hay datos o la conexi√≥n se cierra.

    - send(bytes) intenta enviar bytes al socket; puede enviar menos que la longitud pasada. Para asegurar env√≠o total usar sendall.

## Explotaci√≥n

### 1. Recolectar la Informaci√≥n

Usamos la herramienta nc (netcat) para conectarnos al servidor y obtener el mensaje codificado.

![nc](assets/img/TryHackMe/W1seGuy/nc.png)


### 2. Calculando la Clave Secreta



Este script realiza la "Operaci√≥n M√°gica Inversa" para descifrar la clave de 5 caracteres.

```python
# -*- coding: utf-8 -*-
import socket
import string
import sys
import time

# --- CONFIGURACI√ìN ---
# ¬°IMPORTANTE! Reemplaza "w1seguy.thm" con la IP o nombre de host correcto si es necesario.
HOST = "w1seguy.thm" 
PORT = 1337

# El servidor genera la clave a partir de este conjunto:
KEY_CHARS = string.ascii_letters + string.digits

def setup(key, flag, encode):
    """Aplica la operaci√≥n XOR: Flag XOR Key"""
    xored = ""

    # Itera sobre la longitud de la Flag. El operador % len(key) repite la clave.
    for i in range(0,len(flag)):
        xored += chr(ord(flag[i]) ^ ord(key[i%len(key)]))

    if encode:
        # Convierte el resultado XOR a HEX para la comparaci√≥n con el servidor
        # Usamos latin1 para manejar caracteres no ASCII
        return xored.encode('latin1').hex()

    # Devuelve la Flag descifrada (Mensaje Original)
    return xored

def main():
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.connect((HOST, PORT))
            s.settimeout(2.0) # Establece un timeout para evitar bloqueos

            # 1. RECIBIR DATOS Y EXTRAER CIFRADO (C)
            
            data = s.recv(4096).decode('utf-8')
            xor_text = ""

            # Bucle para extraer el texto cifrado
            if "This XOR encoded text has flag 1" in data:
                # La cadena HEX est√° despu√©s de los dos puntos
                xor_text = data.split(":")[1].strip().split('\n')[0].strip()
            
            if not xor_text:
                print("‚ùå Error: No se pudo extraer el texto cifrado.")
                sys.exit(1)

            print(f"‚úÖ Paso 1: Texto Cifrado (C) extra√≠do.")
            
            # 2. CALCULAR LA CLAVE (K) POR FUERZA BRUTA DE CONOCIDOS
            
            final_key = ""
            # Sabemos que la Flag 1 (descifrada) empieza con 'THM{'
            known_parts = ["T", "H", "M", "{"] 
            
            # Buscamos los primeros 4 caracteres de la clave
            for i in range(4):
                hex_pair = xor_text[i*2:(i*2)+2] # Extrae los 2 chars HEX (1 byte cifrado)
                known_char = known_parts[i]
                
                # Pruebas de fuerza bruta: (Key XOR Known_Char) debe ser igual a Hex_Pair
                for k_char in KEY_CHARS:
                    if setup(k_char, known_char, True) == hex_pair:
                        final_key += k_char
                        break

            # Buscar el 5to car√°cter de la clave, asumiendo que la Flag 1 termina en '}'
            for k_char in KEY_CHARS:
                tmp_key = final_key + k_char
                
                # Descifrar la Flag 1 con la clave de 5 caracteres
                flag_descifrada = setup(tmp_key, bytes.fromhex(xor_text).decode('latin1'), False)
                
                # Comprobar si el √∫ltimo car√°cter es '}' (formato THM{})
                if flag_descifrada.endswith("}"): 
                    final_key = tmp_key
                    break
            
            if len(final_key) < 5:
                print("‚ùå Error: No se pudo completar la clave de 5 caracteres.")
                sys.exit(1)
            
            print(f"üîë Paso 2: Clave Secreta calculada: {final_key}")
            
            # 3. ENVIAR LA CLAVE (K) Y OBTENER FLAG 2
            
            # Enviar la clave al servidor INMEDIATAMENTE con salto de l√≠nea (\r\n para robustez)
            s.sendall((final_key + "\r\n").encode('utf-8'))
            
            # 4. Leer la respuesta completa (Flag 2)
            response = b""
            try:
                while True:
                    chunk = s.recv(4096)
                    if not chunk:
                        break
                    response += chunk
            except socket.timeout:
                pass 
                
            data = response.decode('utf-8')

            print("\n" + "=" * 40)
            print("RESULTADO FINAL:")
            
            # Imprimir Flag 2
            print(f"Returned text: {data.strip()}") 
            
            # Imprimir Flag 1 (la descifrada)
            flag_descifrada = setup(final_key, bytes.fromhex(xor_text).decode('latin1'), False)
            print(f"La Flag 1 descifrada es: {flag_descifrada} con clave {final_key}")
            print("=" * 40)

    except Exception as e:
        print(f"\n‚ùå Ocurri√≥ un error en la conexi√≥n o el script: {e}")

if __name__ == "__main__":
    main()
```

Ejecuta el script y obtendr√°s ambas flags.

![clave](assets/img/TryHackMe/W1seGuy/clave.png)


- flag1: THM{p1alntExtAtt4ckcAnr3alLyhUrty0urxOr}
- flag2: THM{BrUt3_ForC1nG_XOR_cAn_B3_FuN_nO?}

## Conclusi√≥n

La criptograf√≠a y el analisis de codigo en mi opinion es uno de los campos mas dificiles para mi, que aun con ayuda de IA me ha costado bastantes horas resolver esta maquina, sin duda la ia me ha ayudado mucho a analizar el codigo y generar scripts sin conocimientos apenas.
Siempre es bueno saber un poco de todo, tanto programaci√≥n como criptograf√≠a, espero que os haya gustado.
